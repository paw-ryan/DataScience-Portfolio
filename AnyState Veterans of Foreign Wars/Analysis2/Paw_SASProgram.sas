/* Import */
libname sasdata '/home/u50066252/my_shared_file_links/kevinduffy-deno1/Homework 3';
data work.donor; set sasdata.s_pml_donor_hw_v2; run;

proc contents data=work.donor; run;

/* Task 1, Question 1 */
/* Top/Bottom X% /*
/* use PROC UNIVARIATE to find cut off values - say top and bottom 1% */ 
%let anal_var = lifetime_gift_range; 
proc univariate data=work.donor;
  var &anal_var; 
  output out=work.tmp pctlpts= 1 99 pctlpre = percent; 
run; 
proc print data=work.tmp; run;

/* merge cut off values with master file and generate calculations */ 
data work.hi_low; 
  set work.donor; 
  if _n_ = 1 then set work.tmp; 
  if &anal_var le percent1
   then do; 
  range = "low "; 
  output; 
  end; 
  else if &anal_var ge percent99 then do; 
  range = "high"; 
  output; 
  end; 
run; 
proc sort data=work.hi_low; by &anal_var; run;
proc print data=work.hi_low; var control_number lifetime_gift_range range; run;
proc freq data=work.hi_low; table range; run; 


/* IQR */
/* create a box plot */ 
proc means data=work.donor; var &anal_var;
	output out=work.iqr_stats q3 = upper q1 = lower qrange = iqr;	/* we give the stats a name */
	where control_number notin(.); run;
	proc print data=work.iqr_stats; run;	/* _TYPE_ and _FREQ_ are auto generated by SAS */
	/* quick check that this is the same info generated by PROC UNIVARIATE */
	proc univariate data=work.donor;
		var &anal_var;
		where control_number notin(.);
	run;
	/* flag observation as extreme or not */
	/* merge IQR stats in work.iqr_stats with annuity_master using this trick which appends to each row the single row
	   of work.iqr_stats */
	data work.iqr_test; 
		if _n_ = 1 then set work.iqr_stats;
		set work.donor;
	run;
	/* now create our flag variable */
	%let iqr_mult = 3;	/* we can quickly check how changing the multiple affects our findings */
	
	data work.iqr_test; set work.iqr_test;
		if &anal_var > upper + &iqr_mult*iqr and control_number notin(.) then do;
			ev_flag = "high";
			output;
			end;
		if &anal_var < lower - &iqr_mult*iqr and control_number notin(.) and &anal_var notin(.) then do;
			ev_flag = "low";
			output;
			end; run;
	/* we can count the occurrences using PROC FREQ */
	proc freq data=work.iqr_test; table ev_flag; run;

/* Clustering */
/* ---CREATE MACRO--- */
%let anal_var = lifetime_gift_range; 
%macro clust_out(dsin,varlist,where,pmin,dsout);
/*
	dsin  	= input dataset
	varlist = list of vars used in clustering
	where 	= where condition
	pmin  	= size of cluster, as % of dataset, to label its obs as outliers
	dsout 	= output dataset with outliers identified
*/
*====> invoke FASTCLUS to group obs into 50 clusters;
proc fastclus data=&dsin maxc=50 maxiter=100 cluster=_clusterindex_ out=work.temp_clus noprint;
	var &varlist;
	where &where;
run;
*====> analyze resulting clusters;
proc freq data=work.temp_clus noprint;
	tables _clusterindex_ / out=work.temp_freq;
run;
*====> isolate clusters with a size less than pmin of the dataset size;
data work.temp_low; set work.temp_freq;
	if percent < &pmin and _clusterindex_ notin(.); _outlier_ = 1;
	keep _clusterindex_ _outlier_;
run; 
*====> merge these isolated clsuyers back onto the master dataset;
proc sort data=work.temp_clus; by _clusterindex_; run;
proc sort data=work.temp_low; by _clusterindex_; run;
data &dsout; merge work.temp_clus work.temp_low; by _clusterindex_;
	if _outlier_ = . then _Outlier_ = 0;
run;
*====> print the outlier values;
proc sort data=&dsout; by &varlist; run;
proc print data=&dsout; var &varlist _Outlier_; where _Outlier_ = 1; run;

%mend;
/* ---DONE CREATING MACRO--- */

/* Run statement */
%clust_out(work.donor, &anal_var, control_number notin(.), .006, work.clus_out);
/* quick check of outlier count - if count = 0 then increase pmin */
proc sql; select count(*) into : nobs from work.clus_out  where _outlier_ = 1 and control_number notin(.); quit;	

proc sql; select count(*) into: nobs from sasdata.s_pml_donor_hw_v2 where lifetime_gift_range ge 110; quit;


/* Task 1, Question 2 */
proc means data=work.donor n nmiss min median max; var lifetime_gift_count lifetime_avg_gift_amt; run;


/* Task 2, Question 1 */
/* Import */
libname sasdata '/home/u50066252/my_shared_file_links/kevinduffy-deno1/Homework 3';
data work.donor2; set sasdata.s_pml_donor_hw_v2; run;

/* ---CREATE MACRO--- */
%macro CARDINALITYRATIO(INPUTDATA,OUTPUTDATA,CREATEREPORT);
	%local cnt tot outlib outds;
	%let outlib=%sysfunc(substr(&inputData.,1,%sysfunc(index(&inputData.,.))-1));
	%let outds =%sysfunc(substr(&inputData.,1+%sysfunc(index(&inputData.,.))));
	proc datasets library=&outlib. nolist;
		contents data=&outds. out=work._ds_variables(keep=name type format length) noprint;
	run;
	quit;
  data _null_;
	set &outlib..&outds. nobs=total;
	call symput('tot',strip(total));
	stop;
  run;
  data _null_;
	set work._ds_variables nobs=total;
	call symput('cnt',strip(total));
	stop;
  run;
  proc sql noprint;
	select trim(name) into :char1-:char&cnt. from work._ds_variables;
  quit;
  ods output nlevels=work.char_freqs;
  ods noproctitle;
  title "Summary of levels in &outlib..&outds.";
  proc freq data=&outlib..&outds. nlevels;
	tables
		%do i=1 %to &cnt.;
	&&char&i.
	%end;
	/ noprint;
  run;
  ods proctitle;
  proc sql noprint;
	create table &outputdata. as
		select c.*, 
			ifc(c.type=1,'Numeric','Character') label='Type' as vartype ,
			r.nlevels, r.nlevels / &tot. as PCT_UNIQUE format=percent9.2
		from work._ds_variables c, work.char_freqs r
			where c.name=r.tablevar
				order by r.nlevels descending;
	drop table work._ds_variables;
	drop table work.char_freqs;
  quit;
  %if (&createReport) %then
	  %do;
		title "Cardinality of variables in &outlib..&outds.";
		title2 "Data contains &tot. rows";
		proc print data=&outputData. label noobs;
			label NLevels="Levels" pct_unique="Cardinality_Ratio";
			var name vartype length format nlevels pct_unique;
		run;
	%end;
   title; 
 title2;
%mend;
/* ---DONE CREATING MACRO--- */
%CARDINALITYRATIO(work.donor2,work.annuity_cardinality,1);	

     	

/* Task 2, Question 2 */
/* Import */
libname sasdata '/home/u50066252/my_shared_file_links/kevinduffy-deno1/Homework 3';
data work.dummy1; set sasdata.s_pml_donor_hw_v2;
/* Levels */
proc freq data=work.dummy1; table donor_gender urbanicity recency_status_96nk; run;

/* DONOR_GENDER */
data work.dummy1; set work.dummy1;
	dgF_dum = (donor_gender = "F"); 
	dgM_dum = (donor_gender = "M"); 
	dgU_dum = (donor_gender = "U"); 
	dgA_dum = (donor_gender = "A"); 
run;
%let donor_gender_dums = dgF_dum dgM_dum dgU_dum dgA_dum;
proc means data=work.dummy1 nmiss min mean max sum; var &donor_gender_dums; run;

/* URBANICITY */ 
data work.dummy1; set work.dummy1;
	urbQ_dum = (urbanicity = "?"); 
	urbC_dum = (urbanicity = "C"); 
	urbR_dum = (urbanicity = "R"); 
	urbS_dum = (urbanicity = "S"); 
	urbT_dum = (urbanicity = "T"); 
	urbU_dum = (urbanicity = "U"); 
run;
%let urb_dums = urbQ_dum urbC_dum urbR_dum urbS_dum urbT_dum urbU_dum;
proc means data=work.dummy1 nmiss min mean max sum; var &urb_dums; run;

/* RECENCY_STATUS_ 96NK */
data work.dummy1; set work.dummy1;
	rsA_dum = (recency_status_96nk = "A"); 
	rsE_dum = (recency_status_96nk = "E"); 
	rsF_dum = (recency_status_96nk = "F"); 
	rsL_dum = (recency_status_96nk = "L"); 
	rsN_dum = (recency_status_96nk = "N"); 
	rsS_dum = (recency_status_96nk = "S"); 
run;
%let rs_dums = rsA_dum rsE_dum rsF_dum rsL_dum rsN_dum rsS_dum;
proc means data=work.dummy1 nmiss min mean max sum; var &rs_dums; run;


/* Task 3, Question 1 */
/* Import */
libname sasdata '/home/u50066252/my_shared_file_links/kevinduffy-deno1/Homework 3';
data work.donor3; set sasdata.s_pml_donor_hw_v2;
	 recent_star_status_num = RECENT_STAR_STATUS + 1; run;
%let anal_var = recent_star_status_num;
proc sort data=work.donor3; by &anal_var; run;
proc freq data=work.donor3 order=freq;
	tables &anal_var / out=work.freq (drop = percent); run;
	
proc sort data=work.freq; by &anal_var; run;
proc sort data=work.donor3; by &anal_var; run;

/* Create our dummy variables while applying the check for min_count by segment level */ 
%let min_count = 30; 
data work.dummies; merge work.donor3 work.freq; by &anal_var; 
	array red(23) rstar_dum1-rstar_dum23; 
	do i = 1 to dim(red); if (&anal_var = i and count ge &min_count) 
	then red(i) = 1; else red(i) = 0; 
	end; 
if sum(of rstar_dum1-rstar_dum23) = 0 then rstar_oth = 1; else rstar_oth = 0; run; 

*====> check sums; 
proc means data=work.dummies nmiss min mean max sum; var rstar_dum1-rstar_dum23 rstar_oth;
	output out=work.tmp_sum (drop = _TYPE_ _FREQ_) 
	sum = rstar_dum1-rstar_dum23 rstar_oth; run; 

proc transpose data=work.tmp_sum out=work.tmp_sum_t; run; 
proc print data=work.tmp_sum_t; run;



/* Task 3, Question 2 */
/* Task 3, 2a */
libname sasdata '/home/u50066252/my_shared_file_links/kevinduffy-deno1/Homework 3';
data work.donor3; set sasdata.s_pml_donor_hw_v2;
recent_star_status_num = RECENT_STAR_STATUS + 1; run;
%let segment = target_b; 
%let anal_var = recent_star_status_num; 
proc sort data=work.donor3;
	by &segment; run; 
proc freq data=work.donor3; tables &anal_var; by &segment; where not missing (&segment); run;

proc means data=work.dummies nmiss min mean max sum; 
	class &segment;
	var rstar_dum1-rstar_dum23 rstar_oth;

/* Task 3, 2b */
/* Find freq by segment level and merge onto master */ 
libname sasdata '/home/u50066252/my_shared_file_links/kevinduffy-deno1/Homework 3';
data work.donor3; set sasdata.s_pml_donor_hw_v2;
recent_star_status_num = RECENT_STAR_STATUS + 1; run;
%let segment = target_b; 
%let anal_var = recent_star_status_num; 

proc sort data=work.donor3; by &segment; run; 
proc freq data=work.donor3 order=freq; table &anal_var / out=work.freq (drop = percent);
	by &segment; 
	where not missing(&segment); run; 
data work.seg_1 work.seg_0; set work.freq; 
	if &segment = 1 then output work.seg_1; 
	if &segment = 0 then output work.seg_0; run; 
data work.seg_1; set work.seg_1; count_seg_1 = count; keep &anal_var count_seg_1; run; 
data work.seg_0; set work.seg_0; count_seg_0 = count; keep &anal_var count_seg_0; run; 
proc sort data=work.seg_1; by &anal_var; run; 
proc sort data=work.seg_0; by &anal_var; run; 
proc sort data=work.donor3; by &anal_var; run;

/* Create our dummy variables while applying the check for min_count by segment level */ 
%let min_count = 30; 
data work.dummies; merge work.donor3 work.seg_1 work.seg_0; by &anal_var; 
	array red(23) rstar_dum1-rstar_dum23; 
	do i = 1 to dim(red); if (&anal_var = i and count_seg_0 ge &min_count and count_seg_1 ge &min_count) 
	then red(i) = 1; else red(i) = 0; 
	end;
	if sum(of rstar_dum1-rstar_dum23) = 0 then rstar_oth = 1; else rstar_oth = 0; run; 
*====> check sums by segment; 
proc sort data=work.dummies; by &segment; run; 
proc means data=work.dummies sum; var rstar_dum1-rstar_dum23 rstar_oth;
	output out=work.tmp_sum (drop = _TYPE_ _FREQ_) 
	sum = rstar_dum1-rstar_dum23 rstar_oth; by &segment;
	where not missing(&segment); run; 
proc transpose data=work.tmp_sum out=work.tmp_sum_t; run; 
proc print data=work.tmp_sum_t; run; 


/* Task 4, Question 1 */
/* Task 4, 1a */ 
libname sasdata '/home/u50066252/my_shared_file_links/kevinduffy-deno1/Homework 3';
data work.donor4; set sasdata.s_pml_donor_hw_v2;
%let input_data = work.donor4; 
%let anal_var 	= recent_star_status;
%let target_var = target_b;

*====> First, count the levels in our categorical variable as we did before, just so we know;
proc freq data=&input_data noprint; table &anal_var / out=work.cat_counts; run;
	proc freq data=work.cat_counts noprint; table &anal_var / out=work.cat_counts; run;
		proc sql; select count(*) into: TotalCats from work.cat_counts; quit;

*====> Second, create file with level proportions using a file which also shows the target value;
 proc means data= &input_data noprint nway;		/* nway => only show "yes" or "1" group */
	 class &anal_var;							/* do for each level of category */
	 var &target_var;
	 output out=work.level mean = prop;
 run;
 
proc sort data=work.level; by descending prop; run;
proc print data=work.level; format prop percent10.2; run;
	
	*FREQ of RECENT_STAR_STATUS;
	proc freq data=&input_data; table &anal_var; run;		/* are 13239 accts at "0" recent_star_status */
	*FREQ of RECENT_STAR_STATUS where target_b = 1; 
	proc freq data=&input_data; table &anal_var; where &target_var = 1; run;	/* are 3009 "1" of target_b */
	/* so proportion of "0" accts that have TARGET_B = 1 = 3009/13239*100  or 22.73% */	 
	 
*====> Third, cluster the levels based on the proportions (using Ward's method - all start in one cluster then split apart);

/* Use ODS to output the ClusterHistory output object into a dataset named "cluster." */
ods output clusterhistory=work.cluster;

proc cluster data=work.level method=ward outtree=fortree; 
	freq _freq_;	/* treats each level as occurring the # of times given by the value in _freq_ */
	var prop;
	id &anal_var;
run;

/* examine the hierarchial tree (dendrogram) - clusters occur at the end of long branches */
proc tree data=work.fortree out=work.treeout nclusters=23; id &anal_var;  run;

/* I guess 8 clusters */

*====> Fourth, statistically find optimal number of clusters;

/* Use the FREQ procedure to get the Pearson Chi^2 statistic */
proc freq data=&input_data noprint;
	table &anal_var*&target_var / chisq;
	output out=work.chi(keep=_pchi_) chisq;
run;

/* Use a one-to-many merge to put the Chi^2 statistic onto the clustering results. Calculate a (log) p-value for
   each level of clustering. */
data work.cutoff;
   if _n_=1 then set work.chi;
   set work.cluster;
   chisquare=_pchi_*rsquared;
   degfree=numberofclusters-1;
   logpvalue=logsdf('CHISQ',chisquare,degfree);
run;

/* Plot the log p-values against number of clusters */
title1 "Plot of the Log of the P-value by Number of Clusters";
proc gplot data=work.cutoff;
	plot logpvalue*numberofclusters; run;
	
*====> Fifth, create a macro variable (&ncl) that contains the number of clusters associated with the minimum log p-value;
proc sql;
   select NumberOfClusters into :ncl
   from work.cutoff
   having logpvalue=min(logpvalue);
quit;

*====> Sixth, create a dataset with the cluster name;
proc tree data=work.fortree nclusters=&ncl out=work.clus;
   id &anal_var; run;
proc sort data=work.clus;
   by clusname; run;
title1 "Levels of Categorical Variable by Cluster";
proc print data=work.clus;
   by clusname;
   id clusname; run;

*====> Seventh, merge cluster assignment onto master file and create dummies;
data work.clus2; set work.clus; drop clusname; run;
	proc sort data=work.clus2; by &anal_var; run;
	proc sort data=&input_data; by &anal_var; run;
		data work.scored; merge &input_data work.clus2; by &anal_var; 
			rstar_clus1=(cluster=1);	
			rstar_clus2=(cluster=2);	
			rstar_clus3=(cluster=3); run;
%let dum_vars = rstar_clus1 rstar_clus2 rstar_clus3;
proc means data=work.scored sum; var &dum_vars; run;
		
*====> Eight, check frequences at the target-level;
		proc sort data=work.scored; by &target_var; run;
			proc means data=work.scored sum; var &dum_vars; output out=work.tmp_sum (drop = _TYPE_ _FREQ_)
			sum = &dum_vars; by &target_var; where &target_var notin(.); run;
				proc transpose data=work.tmp_sum out=work.tmp_sum_t; run;
					proc print data=work.tmp_sum_t; run;


/* Extra Credit */
libname sasdata '/home/u50066252/my_shared_file_links/kevinduffy-deno1/Homework 3';
data work.donor_ec; set sasdata.s_pml_donor_hw_v2;
%let anal_var 	= recent_star_status;
%let target_var = target_b;
%let dataset 	= work.donor_ec;	

proc sort data=&dataset; by &anal_var; run;
*===> calculate level data;
proc means data=&dataset sum noprint; var &target_var; by &anal_var; output out=work.level_sum (drop= _TYPE_) sum = events; run;
*===> calculate total data;
proc means data=&dataset sum noprint; var &target_var;  output out=work.total_sum (drop= _TYPE_) sum = tot_events; run;
	data work.total_sum; set work.total_sum; drop _FREQ_;
		tot_non_events 	=	_FREQ_ - tot_events;
		tot_obs			= 	_FREQ_;
		tot_event_prob	=	tot_events/_FREQ_;
	run;
	
*===> merge level with total data and compute stats;	
data work.level_sum; 
	if _n_ = 1 then set work.total_sum;
	set work.level_sum; 
	
	non_events 		= 	_freq_ - events;
	pct_events		=	(events/tot_events);	
	pct_non_events 	= 	(non_events/tot_non_events);
	
	woe 			= log((events/tot_events)/(non_events/tot_non_events));
	iv				=	((events/tot_events)-(non_events/tot_non_events))*woe;
run;	
*===> print out results;
	proc print data=work.level_sum; var &anal_var _freq_ events non_events pct_events pct_non_events woe iv; 
		sum _freq_ events non_events pct_events pct_non_events woe iv; run;
	
/* then, to get the variable-level IV */	
	proc sql; select sum(iv) into: IV from work.level_sum; quit;   




